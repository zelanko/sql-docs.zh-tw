---
title: 交易隔離等級 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: On Demand
ms.openlocfilehash: 28e0bd9447d5975a34e963477eceb61f654d824d
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/16/2018
---
# <a name="transaction-isolation-levels"></a>交易隔離等級
*交易隔離等級*是交易成功隔離程度的量值。 特別是，交易隔離等級的定義方式下列現象存在：  
  
-   **中途讀取**A *dirty 讀取*交易讀取尚未認可的資料時，就會發生。 例如，假設交易 1 更新資料列。 交易 2 會在交易 1 認可更新之前讀取更新的資料列。 如果交易 1 復原變更，交易 2 會有讀取永遠不會被視為已存在的資料。  
  
-   **不可重複讀取**A*不可重複讀取*交易讀取相同的資料列兩次，但每次取得不同的資料時發生。 例如，假設交易 1 讀取資料列。 交易 2 會更新或刪除該資料列，並且認可更新或刪除。 如果交易 1 會重新讀取資料列，它會擷取不同的資料列的值，或會探索已刪除資料列。  
  
-   **虛設項目**A*虛設項目*符合搜尋條件，但不會一開始出現的資料列。 例如，假設在交易 1 讀取一組符合搜尋條件的資料列。 交易 2 會產生新的資料列 （透過更新或插入），符合搜尋準則的交易 1。 如果交易 1 reexecutes 讀取資料列的陳述式，它會取得一組不同的資料列。  
  
 （如 sql-92 所定義） 的四個交易隔離等級是以這些現象定義。 下表中，"X"會標示每個可能發生的現象。  
  
|交易隔離等級|中途讀取|不可重複讀取|虛設項目|  
|---------------------------------|-----------------|-------------------------|--------------|  
|讀取未認可|X|X|X|  
|讀取認可|--|X|X|  
|可重複讀取|--|--|X|  
|可序列化|--|--|--|  
  
 下表描述 DBMS 可能會實作交易隔離等級的簡單方式。  
  
> [!IMPORTANT]  
>  大部分 Dbms 會使用更複雜的配置比這些來增加並行。 這些範例會提供僅供說明用途。 特別是，ODBC 不並未規定如何特定 Dbms 隔離彼此的交易。  
  
|交易隔離|可能的實作|  
|---------------------------|-----------------------------|  
|讀取未認可|不會相互隔離的交易。 如果 DBMS 支援其他交易隔離等級，它會忽略它來實作這些層級會使用任何機制。 使造成不良影響其他的交易，在 Read Uncommitted 等級執行交易是通常是唯讀狀態。|  
|讀取認可|交易等待其他交易寫入鎖定的資料列就會解除鎖定。這樣會避免讀取任何 「 有所變更 」 的資料。<br /><br /> （如果它只會讀取資料列） 的讀取的鎖定或寫入鎖定 （如果它更新或刪除資料列） 來防止其他交易更新或刪除它在目前資料列的交易保留。 關閉目前的資料列移動時，交易就會釋放讀取的鎖定。 認可或回復之前，它會保留寫入鎖定。|  
|可重複讀取|交易等待其他交易寫入鎖定的資料列就會解除鎖定。這樣會避免讀取任何 「 有所變更 」 的資料。<br /><br /> 交易保留讀取的鎖定，它傳回所有資料列插入、 更新或刪除應用程式及寫入鎖定的所有資料列。 例如，如果交易包含 SQL 陳述式**選取\*從訂單**，交易讀取鎖定資料列，因為應用程式會擷取它們。 如果交易包含 SQL 陳述式**刪除從訂單，狀態 = 'CLOSED'**，因為它會刪除交易寫入鎖定的資料列。<br /><br /> 因為其他交易無法更新或刪除這些資料列，目前的交易可避免任何不可重複讀取。 認可或回復時，交易就會釋放它的鎖定。|  
|可序列化|交易等待其他交易寫入鎖定的資料列就會解除鎖定。這樣會避免讀取任何 「 有所變更 」 的資料。<br /><br /> 交易 （如果它只會讀取資料列），請保留讀取的鎖定或寫入鎖定 （如果它可以更新或刪除資料列） 範圍的資料列就會影響。 比方說，如果交易包含 SQL 陳述式**選取\*從訂單**，範圍是整個 Orders 資料表，則交易讀取鎖定資料表，而且不允許插入到它的任何新資料列。 如果交易包含 SQL 陳述式**刪除從訂單，狀態 = 'CLOSED'**，範圍是"CLOSED"的所有資料列狀態，交易寫入鎖定在訂單中的所有資料列資料表且狀態為 「 已關閉 」，而且不會不允許任何資料列插入或更新，使產生的資料列都有狀態為"CLOSED"。<br /><br /> 因為其他交易無法更新或刪除資料列範圍中的，目前的交易可避免任何不可重複讀取。 因為其他交易無法插入任何資料列範圍中，目前的交易可避免任何虛設項目。 認可或回復時，交易就會釋放其鎖定。|  
  
 請務必注意的交易隔離等級不會影響交易的能力，以查看它自己的變更;交易可以永遠看到他們所做的任何變更。 例如，交易可能會包含兩個**更新**陳述式，其中第一個引發百分之 10 的所有員工的付款和第二個超過該數量的一些最大量設定任何員工的付款。 這個動作成功視為單一交易只是因為第二個**更新**陳述式可以檢視測試的第一個結果。

---
title: 交易隔離等級 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 83197b1b487db6c52a8fe9b7a57dd6af55c33571
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/15/2019
ms.locfileid: "67985112"
---
# <a name="transaction-isolation-levels"></a>交易隔離等級
*交易隔離等級*是隔離成功的交易範圍的量值。 特別的是，交易隔離等級會定義由下列的現象存在：  
  
-   **中途讀取**A*中途讀取*發生於某筆交易讀取尚未認可的資料。 例如，假設交易 1 更新資料列。 交易 2 會在交易 1 認可更新之前，讀取更新的資料列。 如果交易 1 回復變更，交易 2 會有讀取永遠不會被視為已存在的資料。  
  
-   **不可重複讀取**A*不可重複讀取*交易讀取相同的資料列兩次，但每次取得不同的資料時，就會發生。 例如，假設交易 1 讀取資料列。 交易 2 更新或刪除該資料列，並認可 update 或 delete。 如果交易 1 會重新讀取資料列，它會擷取不同的資料列的值，或會探索已刪除資料列。  
  
-   **虛設項目**A*虛設項目*符合搜尋條件，但一開始未出現的資料列。 例如，假設交易 1 讀取一組符合搜尋條件的資料列。 交易 2 會產生新的資料列 （透過更新或插入），符合搜尋準則的交易 1。 如果交易 1 reexecutes 讀取資料列的陳述式，它會取得一組不同的資料列。  
  
 （如 SQL-92 所定義） 的四個交易隔離等級會定義以這些現象。 下表中，"X"會標示每個可能發生的現象。  
  
|交易隔離等級|中途讀取|不可重複讀取|虛設項目|  
|---------------------------------|-----------------|-------------------------|--------------|  
|讀取未認可|X|X|X|  
|讀取認可|--|X|X|  
|可重複讀取|--|--|X|  
|可序列化|--|--|--|  
  
 下表說明簡單的方法，DBMS 都可能會實作交易隔離等級。  
  
> [!IMPORTANT]  
>  大部分的 Dbms 會使用比這些更複雜的配置，來增加並行。 提供這些範例僅供說明用途。 特別是，ODBC 並未規定如何特定 Dbms 隔離彼此的交易。  
  
|交易隔離|可能的實作|  
|---------------------------|-----------------------------|  
|讀取未認可|交易不會彼此隔離。 如果 DBMS 支援其他交易隔離等級，它會忽略任何機制，它會使用來實作這些層級。 以便他們造成不良影響其他的交易，通常是唯讀，也會是在 Read Uncommitted 等級執行交易。|  
|讀取認可|交易會等候，直到被其他交易寫入鎖定的資料列就會解除鎖定;這會防止它讀取"dirty"的任何資料。<br /><br /> （如果它只會讀取資料列） 的讀取的鎖定或寫入鎖定 （如果它更新或刪除資料列） 目前的資料列，以防止其他交易更新或刪除交易保存。 移動非目前資料列時，交易就會釋放讀取的鎖定。 認可或回復之前，它就會保留寫入鎖定。|  
|可重複讀取|交易會等候，直到被其他交易寫入鎖定的資料列就會解除鎖定;這會防止它讀取"dirty"的任何資料。<br /><br /> 交易保留讀取的鎖定，它會傳回所有資料列插入、 更新或刪除應用程式及寫入鎖定的所有資料列。 例如，如果交易包含 SQL 陳述式**選取 \*從訂單**，交易讀取鎖定資料列，因為應用程式會擷取它們。 如果交易包含 SQL 陳述式**刪除從訂單，狀態 = 'CLOSED'** ，交易寫入鎖定資料列，因為它會刪除它們。<br /><br /> 因為其他交易無法更新或刪除這些資料列，目前的交易可避免任何不可重複讀取。 認可或回復時，交易就會釋放其鎖定。|  
|可序列化|交易會等候，直到被其他交易寫入鎖定的資料列就會解除鎖定;這會防止它讀取"dirty"的任何資料。<br /><br /> 交易 （如果它只會讀取資料列），請保留讀取的鎖定或寫入鎖定 （如果它可以更新或刪除資料列） 的範圍資料列就會影響。 比方說，如果交易包含 SQL 陳述式**選取 \*從訂單**，範圍是整個訂單資料表，交易讀取鎖定的資料表而且不會不允許任何新的資料列插入到它。 如果交易包含 SQL 陳述式**刪除從訂單，狀態 = 'CLOSED'** ，範圍為"CLOSED"的所有資料列的狀態; 交易寫入鎖定在訂單中的所有資料列資料表狀態為 「 關閉 」，而且不會不允許任何要插入或更新產生的資料列具有的狀態為"CLOSED"的資料列。<br /><br /> 因為其他交易無法更新或刪除資料列範圍內，目前的交易可避免任何不可重複讀取。 因為其他交易無法插入任何資料列範圍內，目前的交易可避免任何虛設項目。 交易認可或回復時，釋放其鎖定。|  
  
 務必要注意的交易隔離等級不會影響交易的能力，以查看它自己的變更;交易一定可以看到所做的任何變更。 例如，交易可能會包含兩個**更新**陳述式，其中的第一個引發的所有員工支付百分之 10 和第二個設定任何員工的全額而定，透過一些最大的數量。 這會成功，當做單一交易只因為第二個**更新**陳述式可以看到的第一個結果。
